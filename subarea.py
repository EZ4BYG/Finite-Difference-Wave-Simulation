from multiprocessing import Process,Pipe,Event
import numpy as np
import math 
import datetime as dt
import time
import copy

# 输出文件格式1:
def write_into_file(u4,XN,ZN):
    print("数据写入文件开始:")
    ARRS = []
    f = open('testfenqunew.txt', 'w+')
    for i in range(XN):
        jointsFrame = u4[i]
        ARRS.append(jointsFrame)
        for ji in range(ZN):
            strNum = str(jointsFrame[ji])
            f.write(strNum)
            f.write(',')
        f.write('\n')
    f.close()
    print("波场快照数据写入完毕!")

# 输出文件格式2:
# def write_into_file(u4,XN,ZN):
#     print("数据写入文件开始:")
#     #ARRS = []
#     f = open('testfenqu2.txt','w+')
#     for i in range(XN):
#         for j in range(ZN):
#             f.write(str(i))
#             f.write(',')
#             f.write(str(j))
#             f.write(',')
#             f.write(str(u4[i][j]))
#             f.write('\n')
#     f.close()
#     print("波长快照数据写入完毕!")

# 输出文件格式3:
# def write_into_file(u4,XN,ZN):
#     print("数据写入文件开始:")
#     f = open('testfenqu2.bin', 'wb')
#     for i in range(XN):
#         for j in range(ZN):
#             f.write(bytes(u4[i][j]))
#         #f.write('\n')
#     f.close()

# 输出文件格式4:
# def write_into_file(u4,XN,ZN):
#     print("数据写入文件开始:")
#     f = open('testorig.txt', 'w+')
#     for i in range(XN):
#         for j in range(ZN):
#             f.write(str(u4[i][j]))
#             f.write('\r\n')
#     f.close()
#     print("写入完毕")


# 进程1:区域1单算
def area1(u1,u2,u3,w,f,num):
    print("区域1开始计算:")
    for k1 in range(KN):
        for i1 in range(2,XN//2+1):
            for j1 in range(2,ZN//2+1):
                # if k和ij的判断?
                # k的判断:第一次k正常算,以后要加入ij的判断;
                # ij的判断:到达临近边界要用别的区域传过来的数值
                uu0 = (v[i1][j1]**2) * (DT/DH)**2

                if k1 == 0:
                    uu1 = -1.0/12*(u2[i1-2][j1] + u2[i1+2][j1]) + \
                           4.0/3*(u2[i1-1][j1] + u2[i1+1][j1]) - \
                           5.0/2*u2[i1][j1]  # 列向算的:因为行变量i在变
                    uu2 = -1.0/12*(u2[i1][j1-2] + u2[i1][j1+2]) + \
                           4.0/3*(u2[i1][j1-1] + u2[i1][j1+1]) - \
                           5.0/2*u2[i1][j1]  # 行向算的:因为列变量j在变
                # k已超过1:开始考虑边界问题
                # 边界性范围,计算公式特殊
                # 下面的特殊边界分成"8种"情况:
                if k1 != 0: 
                    # 蓝色1
                    if i1 == XN//2 and j1 <= ZN//2-1 : 
                        # 和3区交互:"算行的(列变量j在变)"还是自己算,"算列的(行变量i在变)"需要3区东西辅助:
                        # 算列时:上面(-)还是用自己的,下面(+)用2区给的东西
                        uu1 = -1.0/12*(u2[i1-2][j1] + u2_tmp31[i1+2][j1]) + \
                               4.0/3*(u2[i1-1][j1] + u2[i1+1][j1]) - \
                               5.0/2*u2[i1][j1] # 列向算的:+2用区域3
                        uu2 = -1.0/12*(u2[i1][j1-2] + u2[i1][j1+2]) + \
                               4.0/3*(u2[i1][j1-1] + u2[i1][j1+1]) - \
                               5.0/2*u2[i1][j1] # 行向算的:不变

                    # 蓝色2
                    elif j1 == ZN//2 and i1 <= XN//2-1:
                        # 和2区交互:"列向算的(行变量i在变)"还是自己算,"行向算的(列变量j在变)"需要2区东西辅助:
                        # 行向算时:左边(-)还是用自己的,右边(+)用2区给的东西
                        uu1 = -1.0/12*(u2[i1-2][j1] + u2[i1+2][j1]) + \
                               4.0/3*(u2[i1-1][j1] + u2[i1+1][j1]) - \
                               5.0/2*u2[i1][j1] # 列向算的:不变
                        uu2 = -1.0/12*(u2[i1][j1-2] + u2_tmp21[i1][j1+2]) + \
                               4.0/3*(u2[i1][j1-1] + u2[i1][j1+1]) - \
                               5.0/2*u2[i1][j1] # 行向算的:+2用区域2

                    # 红色3:与3区共边
                    elif i1 == XN//2+1 and j1 <= ZN//2-1:
                        uu1 = -1.0/12*(u2[i1-2][j1] + u2_tmp31[i1+2][j1]) + \
                               4.0/3*(u2[i1-1][j1] + u2_tmp31[i1+1][j1]) - \
                               5.0/2*u2[i1][j1] # 列向算的:+1+2用3区
                        uu2 = -1.0/12*(u2[i1][j1-2] + u2[i1][j1+2]) + \
                               4.0/3*(u2[i1][j1-1] + u2[i1][j1+1]) - \
                               5.0/2*u2[i1][j1] # 行向算的:不变

                    # 红色4:与2区共边
                    elif j1 == ZN//2+1 and i1 <= XN//2-1:
                        uu1 = -1.0/12*(u2[i1-2][j1] + u2[i1+2][j1]) + \
                               4.0/3*(u2[i1-1][j1] + u2[i1+1][j1]) - \
                               5.0/2*u2[i1][j1] # 列向算的:不变
                        uu2 = -1.0/12*(u2[i1][j1-2] + u2_tmp21[i1][j1+2]) + \
                               4.0/3*(u2[i1][j1-1] + u2_tmp21[i1][j1+1]) - \
                               5.0/2*u2[i1][j1] # 行向算的:+1+2用2区

                    # 黑圈5
                    elif i1 == XN//2 and j1 == ZN//2:
                        uu1 = -1.0/12*(u2[i1-2][j1] + u2_tmp31[i1+2][j1]) + \
                               4.0/3*(u2[i1-1][j1] + u2[i1+1][j1]) - \
                               5.0/2*u2[i1][j1] # 列向算的:+2用3区
                        uu2 = -1.0/12*(u2[i1][j1-2] + u2_tmp21[i1][j1+2]) + \
                               4.0/3*(u2[i1][j1-1] + u2[i1][j1+1]) - \
                               5.0/2*u2[i1][j1] # 行向算的:+2用2区

                    # 黑圈6:与3区共点
                    elif i1 == XN//2+1 and j1 == ZN//2:
                        uu1 = -1.0/12*(u2[i1-2][j1] + u2_tmp31[i1+2][j1]) + \
                               4.0/3*(u2[i1-1][j1] + u2_tmp31[i1+1][j1]) - \
                               5.0/2*u2[i1][j1] # 列向算的:+1+2用3区
                        uu2 = -1.0/12*(u2[i1][j1-2] + u2_tmp21[i1][j1+2]) + \
                               4.0/3*(u2[i1][j1-1] + u2[i1][j1+1]) - \
                               5.0/2*u2[i1][j1] # 行向算的:+2用2区

                    # 黑圈7:与2区共点
                    elif i1 == XN//2 and j1 == ZN//2+1:
                        uu1 = -1.0/12*(u2[i1-2][j1] + u2_tmp31[i1+2][j1]) + \
                               4.0/3*(u2[i1-1][j1] + u2_tmp31[i1+1][j1]) - \
                               5.0/2*u2[i1][j1] # 列向算的:+2用3区
                        uu2 = -1.0/12*(u2[i1][j1-2] + u2_tmp21[i1][j1+2]) + \
                               4.0/3*(u2[i1][j1-1] + u2_tmp21[i1][j1+1]) - \
                               5.0/2*u2[i1][j1] # 行向算的:+1+2用2区

                    # 黑圈8:共中心点
                    elif i1 == XN//2+1 and j1 == ZN//2+1:
                        uu1 = -1.0/12*(u2[i1-2][j1] + u2_tmp31[i1+2][j1]) + \
                               4.0/3*(u2[i1-1][j1] + u2_tmp31[i1+1][j1]) - \
                               5.0/2*u2[i1][j1] # 列向算的:+1+2用3区
                        uu2 = -1.0/12*(u2[i1][j1-2] + u2_tmp21[i1][j1+2]) + \
                               4.0/3*(u2[i1][j1-1] + u2_tmp21[i1][j1+1]) - \
                               5.0/2*u2[i1][j1] # 行向算的:+1+2用2区

                    else:
                        uu1 = -1.0/12*(u2[i1-2][j1] + u2[i1+2][j1]) + \
                               4.0/3*(u2[i1-1][j1] + u2[i1+1][j1]) - \
                               5.0/2*u2[i1][j1]  # 列向算的:因为行变量i在变
                        uu2 = -1.0/12*(u2[i1][j1-2] + u2[i1][j1+2]) + \
                               4.0/3*(u2[i1][j1-1] + u2[i1][j1+1]) - \
                               5.0/2*u2[i1][j1]  # 行向算的:因为列变量j在变

                u3[i1][j1] = 2*u2[i1][j1] - u1[i1][j1] + \
                             uu0*uu1 + uu0*uu2 + \
                             w[k1]*f[i1][j1]  # u2 u1都还是上一轮的东西
                # if i1 == XN//2 and j1 == ZN//2:
                #     print(u3[i1][j1])

        u1 = copy.copy(u2)
        u2 = copy.copy(u3)
        # 给1,3区域发送数据:二维数组的切片
        # 备选:area1_conn12.send(u2[XN//2-1:XN//2+1][ZN//2-1:ZN//2+1])
        area12_conn12.send(u2)  # 给区域2发:全发,但是对方用的时候刚好会在"循环中"用需要的部分
        area13_conn13.send(u2)  # 给区域3发:同上
        # 接收1,3区域发来的数据:同样全接,
        u2_tmp21 = area12_conn12.recv()  # 21表示2区给1区的
        u2_tmp31 = area13_conn13.recv()

        if k1 == num:
            conn1.send(u3)
    print("区域1结束!")
        

# 进程2:区域2单算
def area2(u1,u2,u3,w,f,num):
    print("区域2开始计算:")
    for k2 in range(KN):
        for i2 in range(2,XN//2+1):
            for j2 in range(ZN//2,ZN-2):
                uu0 = (v[i2][j2]**2) * (DT/DH)**2

                if k2 == 0:
                    uu1 = -1.0/12*(u2[i2-2][j2] + u2[i2+2][j2]) + \
                           4.0/3*(u2[i2-1][j2] + u2[i2+1][j2]) - \
                           5.0/2*u2[i2][j2]
                    uu2 = -1.0/12*(u2[i2][j2-2] + u2[i2][j2+2]) + \
                           4.0/3*(u2[i2][j2-1] + u2[i2][j2+1]) - \
                           5.0/2*u2[i2][j2]
                # 分8种情况:           
                if k2 !=0:
                    # 蓝1
                    if i2 == XN//2 and j2 >= ZN//2+3:
                        uu1 = -1.0/12*(u2[i2-2][j2] + u2_tmp42[i2+2][j2]) + \
                               4.0/3*(u2[i2-1][j2] + u2[i2+1][j2]) - \
                               5.0/2*u2[i2][j2]  # 列向算的:+2用区域4
                        uu2 = -1.0/12*(u2[i2][j2-2] + u2[i2][j2+2]) + \
                               4.0/3*(u2[i2][j2-1] + u2[i2][j2+1]) - \
                               5.0/2*u2[i2][j2]  # 行向算:不变

                    # 蓝2
                    elif j2 == ZN//2+2 and i2 <= XN//2-1:
                        uu1 = -1.0/12*(u2[i2-2][j2] + u2[i2+2][j2]) + \
                               4.0/3*(u2[i2-1][j2] + u2[i2+1][j2]) - \
                               5.0/2*u2[i2][j2]  # 列向算的:不变
                        uu2 = -1.0/12*(u2_tmp12[i2][j2-2] + u2[i2][j2+2]) + \
                               4.0/3*(u2[i2][j2-1] + u2[i2][j2+1]) - \
                               5.0/2*u2[i2][j2]  # 行向算:-2用区域1

                    # 红3:与4区共边
                    elif i2 == XN//2+1 and j2 >= ZN//2+3:
                        uu1 = -1.0/12*(u2[i2-2][j2] + u2_tmp42[i2+2][j2]) + \
                               4.0/3*(u2[i2-1][j2] + u2_tmp42[i2+1][j2]) - \
                               5.0/2*u2[i2][j2]  # 列向算的:+1+2用区域4
                        uu2 = -1.0/12*(u2[i2][j2-2] + u2[i2][j2+2]) + \
                               4.0/3*(u2[i2][j2-1] + u2[i2][j2+1]) - \
                               5.0/2*u2[i2][j2]  # 行向算:不变

                    # 红4:与1区共边
                    elif j2 == ZN//2+1 and i2 <= XN//2-1:
                        uu1 = -1.0/12*(u2[i2-2][j2] + u2[i2+2][j2]) + \
                               4.0/3*(u2[i2-1][j2] + u2[i2+1][j2]) - \
                               5.0/2*u2[i2][j2]  # 列向算的:不变
                        uu2 = -1.0/12*(u2_tmp12[i2][j2-2] + u2[i2][j2+2]) + \
                               4.0/3*(u2_tmp12[i2][j2-1] + u2[i2][j2+1]) - \
                               5.0/2*u2[i2][j2]  # 行向算:-1-2用区域1

                    # 黑圈5
                    elif i2 == XN//2 and j2 == ZN//2+2:
                        uu1 = -1.0/12*(u2[i2-2][j2] + u2_tmp42[i2+2][j2]) + \
                               4.0/3*(u2[i2-1][j2] + u2[i2+1][j2]) - \
                               5.0/2*u2[i2][j2]  # 列向算的:+2用区域4
                        uu2 = -1.0/12*(u2_tmp12[i2][j2-2] + u2[i2][j2+2]) + \
                               4.0/3*(u2[i2][j2-1] + u2[i2][j2+1]) - \
                               5.0/2*u2[i2][j2]  # 行向算:-2用区域1

                    # 黑圈6:与4区共点
                    elif i2 == XN//2+1 and j2 == ZN//2+2:
                        uu1 = -1.0/12*(u2[i2-2][j2] + u2_tmp42[i2+2][j2]) + \
                               4.0/3*(u2[i2-1][j2] + u2_tmp42[i2+1][j2]) - \
                               5.0/2*u2[i2][j2]  # 列向算的:+1+2用区域4
                        uu2 = -1.0/12*(u2_tmp12[i2][j2-2] + u2[i2][j2+2]) + \
                               4.0/3*(u2[i2][j2-1] + u2[i2][j2+1]) - \
                               5.0/2*u2[i2][j2]  # 行向算:-2用区域1

                    # 黑圈7:与区域1共点
                    elif i2 == XN//2 and j2 == ZN//2+1:
                        uu1 = -1.0/12*(u2[i2-2][j2] + u2_tmp42[i2+2][j2]) + \
                               4.0/3*(u2[i2-1][j2] + u2[i2+1][j2]) - \
                               5.0/2*u2[i2][j2]  # 列向算的:+2用区域4
                        uu2 = -1.0/12*(u2_tmp12[i2][j2-2] + u2[i2][j2+2]) + \
                               4.0/3*(u2_tmp12[i2][j2-1] + u2[i2][j2+1]) - \
                               5.0/2*u2[i2][j2]  # 行向算:-1-2用区域1

                    # 黑圈8:共中心点
                    elif i2 == XN//2+1 and j2 == ZN//2+1:
                        uu1 = -1.0/12*(u2[i2-2][j2] + u2_tmp42[i2+2][j2]) + \
                               4.0/3*(u2[i2-1][j2] + u2_tmp42[i2+1][j2]) - \
                               5.0/2*u2[i2][j2]  # 列向算的:+1+2用区域4
                        uu2 = -1.0/12*(u2_tmp12[i2][j2-2] + u2[i2][j2+2]) + \
                               4.0/3*(u2_tmp12[i2][j2-1] + u2[i2][j2+1]) - \
                               5.0/2*u2[i2][j2]  # 行向算:-1-2用区域1

                    else:
                        uu1 = -1.0/12*(u2[i2-2][j2] + u2[i2+2][j2]) + \
                               4.0/3*(u2[i2-1][j2] + u2[i2+1][j2]) - \
                               5.0/2*u2[i2][j2]
                        uu2 = -1.0/12*(u2[i2][j2-2] + u2[i2][j2+2]) + \
                               4.0/3*(u2[i2][j2-1] + u2[i2][j2+1]) - \
                               5.0/2*u2[i2][j2]

                u3[i2][j2] = 2*u2[i2][j2] - u1[i2][j2] + \
                             uu0*uu1 + uu0*uu2 + \
                             w[k2]*f[i2][j2]


        # 区域性数值更新:
        u1 = copy.copy(u2)
        u2 = copy.copy(u3)
        # 接收数据:
        u2_tmp12 = area12_conn21.recv()
        u2_tmp42 = area42_conn24.recv()
        # 数据发送:
        area12_conn21.send(u2)
        area42_conn24.send(u2)

        if k2 == num:
            conn2.send(u3)
    print("区域2结束!")


# 进程3:区域3单算
def area3(u1,u2,u3,w,f,num):
    print("区域3开始计算:")
    for k3 in range(KN):
        for i3 in range(XN//2+1,XN-2):
            for j3 in range(2,ZN//2+1):
                uu0 = (v[i3][j3]**2) * (DT/DH)**2

                if k3 == 0:
                    uu1 = -1.0/12*(u2[i3-2][j3] + u2[i3+2][j3]) + \
                           4.0/3*(u2[i3-1][j3] + u2[i3+1][j3]) - \
                           5.0/2*u2[i3][j3]
                    uu2 = -1.0/12*(u2[i3][j3-2] + u2[i3][j3+2]) + \
                           4.0/3*(u2[i3][j3-1] + u2[i3][j3+1]) - \
                           5.0/2*u2[i3][j3]

                # 分8种情况:
                if k3 !=0:
                    # 蓝1
                    if i3 == XN//2+2 and j3 <= ZN//2-1:
                        uu1 = -1.0/12*(u2_tmp13[i3-2][j3] + u2[i3+2][j3]) + \
                               4.0/3*(u2[i3-1][j3] + u2[i3+1][j3]) - \
                               5.0/2*u2[i3][j3]  # 列向算的:-2用区域1
                        uu2 = -1.0/12*(u2[i3][j3-2] + u2[i3][j3+2]) + \
                               4.0/3*(u2[i3][j3-1] + u2[i3][j3+1]) - \
                               5.0/2*u2[i3][j3]  # 列向算的:不变

                    # 蓝2
                    elif j3 == ZN//2 and i3 >= XN//2+3:
                        uu1 = -1.0/12*(u2[i3-2][j3] + u2[i3+2][j3]) + \
                               4.0/3*(u2[i3-1][j3] + u2[i3+1][j3]) - \
                               5.0/2*u2[i3][j3]  # 列向算的:不变
                        uu2 = -1.0/12*(u2[i3][j3-2] + u2_tmp43[i3][j3+2]) + \
                               4.0/3*(u2[i3][j3-1] + u2[i3][j3+1]) - \
                               5.0/2*u2[i3][j3]  # 行向算的:+2用区域4

                    # 红3:与1区共边
                    elif i3 == XN//2+1 and j3 <= ZN//2-1:
                        uu1 = -1.0/12*(u2_tmp13[i3-2][j3] + u2[i3+2][j3]) + \
                               4.0/3*(u2_tmp13[i3-1][j3] + u2[i3+1][j3]) - \
                               5.0/2*u2[i3][j3]  # 列向算的:-1-2用区域1
                        uu2 = -1.0/12*(u2[i3][j3-2] + u2[i3][j3+2]) + \
                               4.0/3*(u2[i3][j3-1] + u2[i3][j3+1]) - \
                               5.0/2*u2[i3][j3]  # 列向算的:不变

                    # 红4:与4区共边
                    elif j3 == ZN//2+1 and i3 >= XN//2+3:
                        uu1 = -1.0/12*(u2[i3-2][j3] + u2[i3+2][j3]) + \
                               4.0/3*(u2[i3-1][j3] + u2[i3+1][j3]) - \
                               5.0/2*u2[i3][j3]  # 列向算的:不变
                        uu2 = -1.0/12*(u2[i3][j3-2] + u2_tmp43[i3][j3+2]) + \
                               4.0/3*(u2[i3][j3-1] + u2_tmp43[i3][j3+1]) - \
                               5.0/2*u2[i3][j3]  # 行向算的:+1+2用区域4

                    # 黑圈5
                    elif i3 == XN//2+2 and j3 == ZN//2:
                        uu1 = -1.0/12*(u2_tmp13[i3-2][j3] + u2[i3+2][j3]) + \
                               4.0/3*(u2[i3-1][j3] + u2[i3+1][j3]) - \
                               5.0/2*u2[i3][j3]  # 列向算的:-2用区域1
                        uu2 = -1.0/12*(u2[i3][j3-2] + u2_tmp43[i3][j3+2]) + \
                               4.0/3*(u2[i3][j3-1] + u2[i3][j3+1]) - \
                               5.0/2*u2[i3][j3]  # 行向算的:+2用区域4

                    # 黑圈6:与1区共点
                    elif i3 == XN//2+1 and j3 == ZN//2:
                        uu1 = -1.0/12*(u2_tmp13[i3-2][j3] + u2[i3+2][j3]) + \
                               4.0/3*(u2_tmp13[i3-1][j3] + u2[i3+1][j3]) - \
                               5.0/2*u2[i3][j3]  # 列向算的:-1-2用区域1
                        uu2 = -1.0/12*(u2[i3][j3-2] + u2_tmp43[i3][j3+2]) + \
                               4.0/3*(u2[i3][j3-1] + u2[i3][j3+1]) - \
                               5.0/2*u2[i3][j3]  # 行向算的:+2用区域4

                    # 黑圈7:与4区共点
                    elif i3 == XN//2+2 and j3 == ZN//2+1:
                        uu1 = -1.0/12*(u2_tmp13[i3-2][j3] + u2[i3+2][j3]) + \
                               4.0/3*(u2[i3-1][j3] + u2[i3+1][j3]) - \
                               5.0/2*u2[i3][j3]  # 列向算的:-2用区域1
                        uu2 = -1.0/12*(u2[i3][j3-2] + u2_tmp43[i3][j3+2]) + \
                               4.0/3*(u2[i3][j3-1] + u2_tmp43[i3][j3+1]) - \
                               5.0/2*u2[i3][j3]  # 行向算的:+1+2用区域4

                    # 黑圈8:共中心点
                    elif i3 == XN//2+1 and j3 == ZN//2+1:
                        uu1 = -1.0/12*(u2_tmp13[i3-2][j3] + u2[i3+2][j3]) + \
                               4.0/3*(u2_tmp13[i3-1][j3] + u2[i3+1][j3]) - \
                               5.0/2*u2[i3][j3]  # 列向算的:-1-2用区域1
                        uu2 = -1.0/12*(u2[i3][j3-2] + u2_tmp43[i3][j3+2]) + \
                               4.0/3*(u2[i3][j3-1] + u2_tmp43[i3][j3+1]) - \
                               5.0/2*u2[i3][j3]  # 行向算的:+1+2用区域4

                    else:
                        uu1 = -1.0/12*(u2[i3-2][j3] + u2[i3+2][j3]) + \
                               4.0/3*(u2[i3-1][j3] + u2[i3+1][j3]) - \
                               5.0/2*u2[i3][j3]
                        uu2 = -1.0/12*(u2[i3][j3-2] + u2[i3][j3+2]) + \
                               4.0/3*(u2[i3][j3-1] + u2[i3][j3+1]) - \
                               5.0/2*u2[i3][j3]

                u3[i3][j3] = 2*u2[i3][j3] - u1[i3][j3] + \
                             uu0*uu1 + uu0*uu2 + \
                             w[k3]*f[i3][j3]

        # 区域性数值更新:
        u1 = copy.copy(u2)
        u2 = copy.copy(u3)
        # 接收数据:
        u2_tmp13 = area13_conn31.recv()
        u2_tmp43 = area43_conn34.recv()
        # 数据发送:
        area13_conn31.send(u2)
        area43_conn34.send(u2)

        if k3 == num:
            conn3.send(u3)
    print("区域3结束!")


# 进程4:区域4单算
def area4(u1,u2,u3,w,f,num):
    print("区域4开始计算:")
    for k4 in range(KN):
        for i4 in range(XN//2+1,XN-2):
            for j4 in range(ZN//2+1,ZN-2):
                uu0 = (v[i4][j4]**2) * (DT/DH)**2

                if k4 == 0:            
                    uu1 = -1.0/12*(u2[i4-2][j4] + u2[i4+2][j4]) + \
                           4.0/3*(u2[i4-1][j4] + u2[i4+1][j4]) - \
                           5.0/2*u2[i4][j4]
                    uu2 = -1.0/12*(u2[i4][j4-2] + u2[i4][j4+2]) + \
                           4.0/3*(u2[i4][j4-1] + u2[i4][j4+1]) - \
                           5.0/2*u2[i4][j4]
                # 分8种
                if k4 !=0:
                    # 蓝1
                    if i4 < XN//2+3 and j4 >= ZN//2+3:
                        uu1 = -1.0/12*(u2_tmp24[i4-2][j4] + u2[i4+2][j4]) + \
                               4.0/3*(u2[i4-1][j4] + u2[i4+1][j4]) - \
                               5.0/2*u2[i4][j4]  # 列向算的:-2用区域2
                        uu2 = -1.0/12*(u2[i4][j4-2] + u2[i4][j4+2]) + \
                               4.0/3*(u2[i4][j4-1] + u2[i4][j4+1]) - \
                               5.0/2*u2[i4][j4]  # 行向算的:不变

                    # 蓝2
                    elif j4 == ZN//2+2 and i4 >= XN//2+3:
                        uu1 = -1.0/12*(u2[i4-2][j4] + u2[i4+2][j4]) + \
                               4.0/3*(u2[i4-1][j4] + u2[i4+1][j4]) - \
                               5.0/2*u2[i4][j4]  # 列向算的:不变
                        uu2 = -1.0/12*(u2_tmp34[i4][j4-2] + u2[i4][j4+2]) + \
                               4.0/3*(u2[i4][j4-1] + u2[i4][j4+1]) - \
                               5.0/2*u2[i4][j4]  # 行向算的:-2用区域3

                    # 红3:与2区共边
                    elif i4 == XN//2+1 and j4 >= ZN//2+3:
                        uu1 = -1.0/12*(u2_tmp24[i4-2][j4] + u2[i4+2][j4]) + \
                               4.0/3*(u2_tmp24[i4-1][j4] + u2[i4+1][j4]) - \
                               5.0/2*u2[i4][j4]  # 列向算的:-1-2用区域2
                        uu2 = -1.0/12*(u2[i4][j4-2] + u2[i4][j4+2]) + \
                               4.0/3*(u2[i4][j4-1] + u2[i4][j4+1]) - \
                               5.0/2*u2[i4][j4]  # 行向算的:不变

                    # 红4:与3区共边
                    elif j4 == ZN//2+1 and i4 >= XN//2+3:
                        uu1 = -1.0/12*(u2[i4-2][j4] + u2[i4+2][j4]) + \
                               4.0/3*(u2[i4-1][j4] + u2[i4+1][j4]) - \
                               5.0/2*u2[i4][j4]  # 列向算的:不变
                        uu2 = -1.0/12*(u2_tmp34[i4][j4-2] + u2[i4][j4+2]) + \
                               4.0/3*(u2_tmp34[i4][j4-1] + u2[i4][j4+1]) - \
                               5.0/2*u2[i4][j4]  # 行向算的:-1-2用区域3

                    # 黑圈5
                    elif i4 == XN//2+2 and j4 == ZN//2+2:
                        uu1 = -1.0/12*(u2_tmp24[i4-2][j4] + u2[i4+2][j4]) + \
                               4.0/3*(u2[i4-1][j4] + u2[i4+1][j4]) - \
                               5.0/2*u2[i4][j4]  # 列向算的:-2用区域2
                        uu2 = -1.0/12*(u2_tmp34[i4][j4-2] + u2[i4][j4+2]) + \
                               4.0/3*(u2[i4][j4-1] + u2[i4][j4+1]) - \
                               5.0/2*u2[i4][j4]  # 行向算的:-2用区域3

                    # 黑圈6:与2区共点
                    elif i4 == XN//2+1 and j4 == ZN//2+2:
                        uu1 = -1.0/12*(u2_tmp24[i4-2][j4] + u2[i4+2][j4]) + \
                               4.0/3*(u2_tmp24[i4-1][j4] + u2[i4+1][j4]) - \
                               5.0/2*u2[i4][j4]  # 列向算的:-1-2用区域2
                        uu2 = -1.0/12*(u2_tmp34[i4][j4-2] + u2[i4][j4+2]) + \
                               4.0/3*(u2[i4][j4-1] + u2[i4][j4+1]) - \
                               5.0/2*u2[i4][j4]  # 行向算的:-2用区域3

                    # 黑圈7:与3区共点
                    elif i4 == XN//2+2 and j4 == ZN//2+1:
                        uu1 = -1.0/12*(u2_tmp24[i4-2][j4] + u2[i4+2][j4]) + \
                               4.0/3*(u2[i4-1][j4] + u2[i4+1][j4]) - \
                               5.0/2*u2[i4][j4]  # 列向算的:-2用区域2
                        uu2 = -1.0/12*(u2_tmp34[i4][j4-2] + u2[i4][j4+2]) + \
                               4.0/3*(u2_tmp34[i4][j4-1] + u2[i4][j4+1]) - \
                               5.0/2*u2[i4][j4]  # 行向算的:-1-2用区域3

                    # 黑圈8:共中心点
                    elif i4 == XN//2+1 and j4 == ZN//2+1:
                        uu1 = -1.0/12*(u2_tmp24[i4-2][j4] + u2[i4+2][j4]) + \
                               4.0/3*(u2_tmp24[i4-1][j4] + u2[i4+1][j4]) - \
                               5.0/2*u2[i4][j4]  # 列向算的:-1-2用区域2
                        uu2 = -1.0/12*(u2_tmp34[i4][j4-2] + u2[i4][j4+2]) + \
                               4.0/3*(u2_tmp34[i4][j4-1] + u2[i4][j4+1]) - \
                               5.0/2*u2[i4][j4]  # 行向算的:-1-2用区域3

                    else:
                        uu1 = -1.0/12*(u2[i4-2][j4] + u2[i4+2][j4]) + \
                               4.0/3*(u2[i4-1][j4] + u2[i4+1][j4]) - \
                               5.0/2*u2[i4][j4]
                        uu2 = -1.0/12*(u2[i4][j4-2] + u2[i4][j4+2]) + \
                               4.0/3*(u2[i4][j4-1] + u2[i4][j4+1]) - \
                               5.0/2*u2[i4][j4]

                u3[i4][j4] = 2*u2[i4][j4] - u1[i4][j4] + \
                             uu0*uu1 + uu0*uu2 + \
                             w[k4]*f[i4][j4]

        # 区域性数值更新:
        u1 = copy.copy(u2)
        u2 = copy.copy(u3)
        # 数据发送:
        area42_conn42.send(u2)
        area43_conn43.send(u2)
        # 数据接收:
        u2_tmp24 = area42_conn42.recv()
        u2_tmp34 = area43_conn43.recv()

        if  k4 == num:
            conn4.send(u3)
        print("第%d次并行迭代结束!"%(k4+1), '还有%d次迭代!'%(KN-k4-1))
    print("区域4结束!")


# ------------ 初始化 -------------- #

start = dt.datetime.now()
E = math.e    # 自然对数e
PI = math.pi  # 圆周率
cos = math.cos
FM = 30       # 基频
R = 3         # 控制频带宽度的参数
KN = 200      # 采样总次数
XN = 101      # 横向有101个点
ZN = 101      # 纵向有101个点
DH = 5        # 网格中小正方形的边长
DT = 0.001    # 采样时间间隔
num = 50       # 波场快照时间

# 就都用大区域:最后按非0拆解再合并
v = np.zeros([XN,ZN])+2000
u1 = np.zeros([XN,ZN])
u2 = np.zeros([XN,ZN])
u3 = np.zeros([XN,ZN])

# 震源函数1:原始震源
# w = []
# # delay = 0.1
# # idd = delay/DT
# for k in range(KN):
#     # temp = PI*FM*(k-idd)*DT
#     # temp = temp**2
#     # w1 = (1.0-2.0*temp)*(E**(-temp))
#     tmp1 = (-2*PI*FM/R)**2
#     tmp1 = tmp1*(k*DT)*(k*DT)
#     w1 = E**tmp1 * cos(2*PI*FM*k*DT)
#     w.append(w1)

# 震源函数2:雷克子波震源
w = []
for k in range(KN):
    w1 = E ** (- pow(2*PI*FM/R,2)*pow(k*DT,2)) * cos(2*PI*FM*k*DT)
    print("w1",w1)
    w.append(w1)

# 激活函数的初始化:
f = np.zeros([XN,ZN])
for i in range(XN):
    for j in range(ZN):
        if i == XN//2 and j == ZN//2:
            f[i][j] = 1
        else:
            f[i][j] = 0

# 子进程间互传管道
area12_conn12, area12_conn21 = Pipe()
area13_conn13, area13_conn31 = Pipe()
area42_conn42, area42_conn24 = Pipe()
area43_conn43, area43_conn34 = Pipe()
# 子主进程间互传管道
conn1, connz1 = Pipe()
conn2, connz2 = Pipe()
conn3, connz3 = Pipe()
conn4, connz4 = Pipe()

area1process = Process(target = area1, args = (u1,u2,u3,w,f,num))
area2process = Process(target = area2, args = (u1,u2,u3,w,f,num))
area3process = Process(target = area3, args = (u1,u2,u3,w,f,num))
area4process = Process(target = area4, args = (u1,u2,u3,w,f,num))

area1process.start()
area2process.start()
area3process.start()
area4process.start()

area1process.join()
area2process.join()
area3process.join()
area4process.join()

# 主进程接收波场快照数据
u31 = connz1.recv()
u32 = connz2.recv()
u33 = connz3.recv()
u34 = connz4.recv()
u31 = u31[:XN//2+1 , :ZN//2+1]
u32 = u32[:XN//2+1 , ZN//2+1:]
u33 = u33[XN//2+1: , :ZN//2+1]
u34 = u34[XN//2+1: , ZN//2+1:]
u312_tmp = np.append(u31, u32, axis = 1)
u334_tmp = np.append(u33, u34, axis = 1)
u4 = np.append(u312_tmp, u334_tmp, axis = 0)

hang = u4.shape[0]
lie = u4.shape[1]
print("u4行有:",hang)
print("u4列有:",lie)

write_into_file(u4,XN,ZN)

end = dt.datetime.now()
print("分区多进程耗时:", end - start)